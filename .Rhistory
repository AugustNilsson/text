slice(0:plot_n_words_square)
data_p_sq9 <- word_data[word_data$square_categories==9, ] %>%
dplyr::arrange(-n_all.x) %>%
slice(0:plot_n_words_square)
data_p_sq_all <- rbind(data_p_sq1, data_p_sq2, data_p_sq3,
data_p_sq4,             data_p_sq6, #data_p_sq5,
data_p_sq7, data_p_sq8, data_p_sq9)
}
# Select only words below alpha; and then top dot.x
data_p_x <- word_data %>%
dplyr::filter(adjusted_p_values.x < p_alpha) %>%
dplyr::arrange(-dot.x) %>%
slice(0:plot_n_words_p)
# Select plot_n_word_extreme and Select plot_n_word_frequency
word_data_extrem_max_x <- word_data %>%
dplyr::arrange(-dot.x) %>%
slice(0:plot_n_word_extreme)
word_data_extrem_min_x <- word_data %>%
dplyr::arrange(dot.x) %>%
slice(0:plot_n_word_extreme)
word_data_frequency_x <- word_data %>%
dplyr::arrange(-n_all.x) %>%
slice(0:plot_n_word_frequency)
# Select the middle range, order according to frequency and then select the plot_n_words_middle = 5
mean_m_sd_x <- mean(word_data$dot.x, na.rm=TRUE) - (sd(word_data$dot.x, na.rm=TRUE)/10) # TODO Possibility to set this one? It may be that no words comes within thi
mean_p_sd_x <- mean(word_data$dot.x, na.rm=TRUE) + (sd(word_data$dot.x, na.rm=TRUE)/10)
word_data_middle_x <- word_data %>%
dplyr::filter(dplyr::between(word_data$dot.x, mean_m_sd_x, mean_p_sd_x)) %>%
dplyr::arrange(-n_all.x) %>%
slice(0:plot_n_words_middle) # TODO selecting on frequency again. perhaps point to have exact middle?
word_data_x <- word_data %>%
dplyr::left_join(data_p_sq_all %>% dplyr::transmute(words, check_p_square = 1)) %>%
dplyr::left_join(data_p_x %>% dplyr::transmute(words, check_p_x = 1)) %>%
dplyr::left_join(word_data_extrem_max_x %>% dplyr::transmute(words, check_extreme_max_x = 1)) %>%
dplyr::left_join(word_data_extrem_min_x %>% dplyr::transmute(words, check_extreme_min_x = 1)) %>%
dplyr::left_join(word_data_frequency_x %>% dplyr::transmute(words, check_extreme_frequency_x = 1)) %>%
dplyr::left_join(word_data_middle_x %>% dplyr::transmute(words, check_middle_x = 1)) %>%
dplyr::mutate(extremes_all_x = rowSums(cbind(check_p_square, check_p_x, check_extreme_max_x, check_extreme_min_x,
check_extreme_frequency_x, check_middle_x), na.rm = T))
if (is.null(y_axes) == FALSE) { # is.character(p_adjust_method) &
# Computing adjusted p-values
# Select only words below alpha; and then top dot.x
data_p_y <- word_data %>%
dplyr::filter(adjusted_p_values.y < p_alpha) %>%
dplyr::arrange(-dot.y) %>%
slice(0:plot_n_words_p)
# Select plot_n_word_extreme and Select plot_n_word_frequency
word_data_extrem_max_y <- word_data %>%
dplyr::arrange(-dot.y) %>%
slice(0:plot_n_word_extreme)
word_data_extrem_min_y <- word_data %>%
dplyr::arrange(dot.y) %>%
slice(0:plot_n_word_extreme)
word_data_frequency_y <- word_data %>%
dplyr::arrange(-n_all.y) %>%
slice(0:plot_n_word_frequency)
# Select the middle range, order according to frequency and then select the plot_n_words_middle =5
mean_m_sd_y <- mean(word_data$dot.y, na.rm=TRUE) - (sd(word_data$dot.y, na.rm=TRUE)/10) # TODO Possibility to set this one? It may be that no words comes within this range
mean_p_sd_y <- mean(word_data$dot.y, na.rm=TRUE) + (sd(word_data$dot.y, na.rm=TRUE)/10)
word_data_middle_y <- word_data %>%
dplyr::filter(dplyr::between(word_data$dot.y, mean_m_sd_y, mean_p_sd_y)) %>%
dplyr::arrange(-n_all.y) %>%
slice(0:plot_n_words_middle) # TODO selecting on frequency again. perhaps point to have exact middle?
word_data_all <- word_data_x %>%
dplyr::left_join(data_p_y %>% dplyr::transmute(words, check_p_y = 1)) %>%
dplyr::left_join(word_data_extrem_max_y %>% dplyr::transmute(words, check_extreme_max_y = 1)) %>%
dplyr::left_join(word_data_extrem_min_y %>% dplyr::transmute(words, check_extreme_min_y = 1)) %>%
dplyr::left_join(word_data_frequency_y %>% dplyr::transmute(words, check_extreme_frequency_y = 1)) %>%
dplyr::left_join(word_data_middle_y %>% dplyr::transmute(words, check_middle_y = 1)) %>%
dplyr::mutate(extremes_all_y = rowSums(cbind(check_p_y, check_extreme_max_y, check_extreme_min_y,
check_extreme_frequency_y, check_middle_y), na.rm = T)) %>%
dplyr::mutate(extremes_all = rowSums(cbind(extremes_all_x, extremes_all_y), na.rm = T))
# Categorise words to apply specific color
word_data_all <- word_data_all %>%
dplyr::mutate(colour_categories = dplyr::case_when(
dot.x < 0 & adjusted_p_values.x < p_alpha  &  dot.y > 0 & adjusted_p_values.y < p_alpha ~ bivariate_color_codes[1],
adjusted_p_values.x > p_alpha  &  dot.y > 0 & adjusted_p_values.y < p_alpha ~ bivariate_color_codes[2],
dot.x > 0 & adjusted_p_values.x < p_alpha  &  dot.y > 0 & adjusted_p_values.y < p_alpha ~ bivariate_color_codes[3],
dot.x < 0 & adjusted_p_values.x < p_alpha  &              adjusted_p_values.y > p_alpha ~ bivariate_color_codes[4],
adjusted_p_values.x > p_alpha  &              adjusted_p_values.y > p_alpha ~ bivariate_color_codes[5],
dot.x > 0 & adjusted_p_values.x < p_alpha  &              adjusted_p_values.y > p_alpha ~ bivariate_color_codes[6],
dot.x < 0 & adjusted_p_values.x < p_alpha  &  dot.y < 0 & adjusted_p_values.y < p_alpha ~ bivariate_color_codes[7],
adjusted_p_values.x > p_alpha  &  dot.y < 0 & adjusted_p_values.y < p_alpha ~ bivariate_color_codes[8],
dot.x > 0 & adjusted_p_values.x < p_alpha  &  dot.y < 0 & adjusted_p_values.y < p_alpha ~ bivariate_color_codes[9]
))
}
if (is.null(y_axes) == TRUE) {
word_data_all <- word_data_x %>%
dplyr::mutate(colour_categories = dplyr::case_when(
dot.x < 0 & adjusted_p_values.x < p_alpha   ~ bivariate_color_codes[4],
dot.x < 0 & adjusted_p_values.x > p_alpha   ~ bivariate_color_codes[5],
dot.x > 0 & adjusted_p_values.x < p_alpha   ~ bivariate_color_codes[6]
))
}
# This solution is because it is not possible to send "0" as a parameter
if (is.null(y_axes) == TRUE) {
only_x_dimension <- 0
y_axes <- "only_x_dimension"
}
# Plot
plot <-
# construct ggplot; the !!sym( ) is to  turn the strings into symbols.
ggplot2::ggplot(data = word_data_all, ggplot2::aes(!!rlang::sym(x_axes), !!rlang::sym(y_axes), label = words)) +
ggplot2::geom_point(
data = word_data_all, # [word_data_all$extremes_all_x==0 | word_data_all$extremes_all_y==0, ]
size = points_without_words_size,
alpha = points_without_words_alpha,
ggplot2::aes(color = colour_categories)
) +
# ggrepel geom, make arrows transparent, color by rank, size by n
ggrepel::geom_text_repel(
data = word_data_all[word_data_all$extremes_all_x==1 | word_data_all$extremes_all_y==1, ],
segment.alpha  = arrow_transparency,
position = ggplot2::position_jitter(h = position_jitter_hight, w = position_jitter_width),
ggplot2::aes(color = colour_categories, size = n_all.x, family = word_font),
) +
ggplot2::scale_color_identity() +
# Decide size and color of the points
ggplot2::geom_point(
data = word_data_all[word_data_all$extremes_all_x==1 | word_data_all$extremes_all_y==1, ],
size = point_size,
ggplot2::aes(color = colour_categories)
) +
# set word size range and the guide
ggplot2::scale_size_continuous(
range = word_size_range,
guide = ggplot2::guide_legend(
title = "Frequency",
title.position = "top",
direction = "horizontal",
label.position = "bottom",
ggplot2::element_text(color = titles_color))
) +
# Title
ggplot2::ggtitle(paste0(title_top)) +
ggplot2::labs(y = y_axes_label, x = x_axes_label) +
# Help create possibility to remove y-axes numbers help(scale_y_continuous)
ggplot2::scale_x_continuous(limits = scale_x_axes_lim) +
ggplot2::scale_y_continuous(limits = scale_y_axes_lim) +
# Minimal theme, and turning off legends
ggplot2::theme_minimal() +
ggplot2::theme(
legend.position = c("bottom"),
plot.title = element_text(hjust = 0.5),
legend.justification = c("right", "top"),
panel.grid.major = ggplot2::element_blank(),
panel.grid.minor = ggplot2::element_blank(),
axis.text.y = y_axes_values,
title = ggplot2::element_text(color = titles_color),
axis.title.x = ggplot2::element_text(color = titles_color),
axis.title.y = ggplot2::element_text(color = titles_color)
)
# Creating legend
bivariate_color_data <- tibble::tibble( "1 - 3" = "#0078FF", "2 - 3" = "blue", "3 - 3" = "#49FF00", "1 - 2" = "#8700FF", "2 - 2" = "#B8B8B8", "3 - 2" = "#34AC04", "1 - 1" = "#FF1300", "2 - 1" = "#FF8300", "3 - 1" = "#04AC93")
bivariate_color_data <- rbind(bivariate_color_data, bivariate_color_codes)
bivariate_color_data = bivariate_color_data[-1, ]
if (y_axes == "only_x_dimension") {
# Only select 3 colours
bivariate_color_data <- bivariate_color_data[, c(4, 5, 6)]
colnames(bivariate_color_data) <- c("1 - 2", "2 - 2", "3 - 2")
bivariate_color_data
# Remove the y axes title on the legend
legend_y_axes_label <- " "
}
legend <- bivariate_color_data %>%
tidyr::gather("group", "fill") %>%
tidyr::separate(group, into = c("x", "y"), sep = " - ") %>%
dplyr::mutate(x = as.integer(x),
y = as.integer(y)) %>%
ggplot2::ggplot(ggplot2::aes(x, y)) +
ggplot2::geom_tile(ggplot2::aes(fill = fill)) +
ggplot2::ggtitle(paste0(legend_title)) +
ggplot2::scale_fill_identity() +
ggplot2::labs(x = legend_x_axes_label,
y = legend_y_axes_label) +
ggplot2::theme_void() +
#    ggplot2::annotate(geom="text", x=2, y=2, label="ns",
#               color = titles_color, size=legend_number_size)+
ggplot2::annotate(geom="text", x=1, y=3, label = sum(word_data_all$colour_categories == bivariate_color_codes[1], na.rm=T),
color = titles_color, size = legend_number_size)+
ggplot2::annotate(geom="text", x=2, y=3, label = sum(word_data_all$colour_categories == bivariate_color_codes[2], na.rm=T),
color = titles_color, size = legend_number_size)+
ggplot2::annotate(geom="text", x=3, y=3, label = sum(word_data_all$colour_categories == bivariate_color_codes[3], na.rm=T),
color = titles_color, size = legend_number_size)+
ggplot2::annotate(geom="text", x=1, y=2, label = sum(word_data_all$colour_categories == bivariate_color_codes[4], na.rm=T),
color = titles_color, size = legend_number_size)+
ggplot2::annotate(geom="text", x=2, y=2, label = sum(word_data_all$colour_categories == bivariate_color_codes[5], na.rm=T),
color = titles_color, size = legend_number_size)+
ggplot2::annotate(geom="text", x=3, y=2, label = sum(word_data_all$colour_categories == bivariate_color_codes[6], na.rm=T),
color = titles_color, size = legend_number_size)+
ggplot2::annotate(geom="text", x=1, y=1, label = sum(word_data_all$colour_categories == bivariate_color_codes[7], na.rm=T),
color = titles_color, size = legend_number_size)+
ggplot2::annotate(geom="text", x=2, y=1, label = sum(word_data_all$colour_categories == bivariate_color_codes[8], na.rm=T),
color = titles_color, size = legend_number_size)+
ggplot2::annotate(geom="text", x=3, y=1, label = sum(word_data_all$colour_categories == bivariate_color_codes[9], na.rm=T),
color = titles_color, size = legend_number_size)+
ggplot2::theme(plot.title = element_text(hjust = 0.5, size = legend_title_size+1),
title = ggplot2::element_text(color = titles_color),
axis.title.x = ggplot2::element_text(color = titles_color),
axis.title = element_text(size = legend_title_size),
axis.title.y = element_text(angle = 90, color = titles_color)) +
ggplot2::coord_fixed()
# Plot both figure and legend help(ggdraw)
cowplot::ggdraw() +
cowplot::draw_plot(plot, 0, 0, 1, 1) +
cowplot::draw_plot(legend, legend_x_position, legend_y_position, legend_h_size, legend_w_size)
plot_projection <- textPlotViz(
word_data = sq_data_plottingHw_HILSSSWLS_100,
k_n_words_two_test = FALSE,
x_axes = "dot.x",
y_axes = "dot.y",
p_values_x = "p_values_dot.x",
p_values_y = "p_values_dot.y",
p_alpha = 0.05,
plot_n_words_p = 50,
x_axes_label = "Dot product",
y_axes_label = NULL,
p_adjust_method = "holm",
title_top = "Dot-Project",
scale_y_axes_lim = NULL
)
plot_projection <- textPlotViz(
word_data = sq_data_plottingHw_HILSSSWLS_100,
k_n_words_two_test = TRUE,
x_axes = "dot.x",
y_axes = "dot.y",
p_values_x = "p_values_dot.x",
p_values_y = "p_values_dot.y",
p_alpha = 0.05,
plot_n_words_p = 50,
x_axes_label = "Dot product",
y_axes_label = NULL,
p_adjust_method = "holm",
title_top = "Dot-Project",
scale_y_axes_lim = NULL
)
plot_projection
devtools::document()
library(text)
library(text)
devtools::document()
library(text)
devtools::document()
devtools::document()
devtools::document()
library(text)
library(text)
devtools::document()
library(text)
x <-  c("I am here")
textEmbed(x)
textTransform(x)
library(text)
textTransform(x)
library(text)
textTransform(x)
library(text)
textTransform(x)
library(text)
textTransform(x)
library(text)
textTransform(x)
library(text)
textTransform(x)
textTransform(x)
devtools::document()
devtools::document()
library(text)
devtools::document()
library(text)
py_config()
library(reticulate)
py_config()
textTransform(x)
library(text)
devtools::document()
library(text)
?.onAttach
library(text)
library(text)
x <-  c("I am here", "where are you")
textTransform(x)
library(text)
library(text)
textTransform(x)
source('~/Desktop/1 Projects/0 Research/0 text r-package/text/R/zzz.R', echo=TRUE)
source('~/Desktop/1 Projects/0 Research/0 text r-package/text/R/zzz.R', echo=TRUE)
source('~/Desktop/1 Projects/0 Research/0 text r-package/text/R/zzz.R', echo=TRUE)
source('~/Desktop/1 Projects/0 Research/0 text r-package/text/R/zzz.R', echo=TRUE)
gc()
source('~/Desktop/1 Projects/0 Research/0 text r-package/text/R/zzz.R', echo=TRUE)
library(text)
library(text)
file.path("inst", "python")
# Load the module and create dummy objects from it, all of which are NULL
the_py_module <- reticulate::import_from_path(
"the_py_module",
file.path("inst", "python")
)
the_py_module
the_py_module
# Now all those names are in the namespace, and ready to be replaced on load
.onLoad <- function(libname, pkgname) {
the_py_module <- reticulate::import_from_path(
"the_py_module",
system.file("python", package = packageName()),
delay_load = TRUE
)
# assignInMyNamespace(...) is meant for namespace manipulation
for (obj in names(the_py_module)) {
assignInMyNamespace(obj, the_py_module[[obj]])
}
}
names(the_py_module)
# Clean up
rm(the_py_module)
obj
for (obj in names(the_py_module)) {
assign(obj, NULL)
}
# Load the module and create dummy objects from it, all of which are NULL
the_py_module <- reticulate::import_from_path(
"the_py_module",
file.path("inst", "python")
)
for (obj in names(the_py_module)) {
assign(obj, NULL)
}
obj
# Clean up
rm(the_py_module)
obj
# Load the module and create dummy objects from it, all of which are NULL
the_py_module <- reticulate::import_from_path(
"the_py_module",
file.path("inst", "python")
)
for (obj in names(the_py_module)) {
assign(obj, NULL)
}
# Clean up
rm(the_py_module)
obj
the_py_module
the_py_module <- reticulate::import_from_path(
"the_py_module",
system.file("python", package = packageName()),
delay_load = TRUE
)
the_py_module <- reticulate::import_from_path(
"the_py_module",
system.file("python", package = packageName())
)
the_py_module
the_py_module <- reticulate::import_from_path(
"the_py_module",
system.file("python", package = packageName()),
delay_load = TRUE
)
the_py_module <- reticulate::source_python(
"the_py_module",
system.file("python", package = packageName()),
delay_load = TRUE
)
the_py_module <- reticulate::source_python(
"the_py_module",
system.file("python", package = packageName())
)
the_py_module <- reticulate::source_python(
"the_py_module.py",
system.file("python", package = packageName())
)
the_py_module <- reticulate::source_python(
"the_py_module",
system.file("python", package = packageName())
)
help(source_python)
help(import_from_path)
help(import_from_path)
# Load the module and create dummy objects from it, all of which are NULL
the_py_module <- reticulate::import_from_path(
"the_py_module",
file.path("inst", "python")
)
for (obj in names(the_py_module)) {
assign(obj, NULL)
}
# Clean up
rm(the_py_module)
the_py_module <- reticulate::import(
"the_py_module",
system.file("python", package = packageName()),
delay_load = TRUE
)
the_py_module <- reticulate::import(
"the_py_module",
system.file("python", package = packageName())
)
# Load the module and create dummy objects from it, all of which are NULL
the_py_module <- reticulate::import_from_path(
"the_py_module",
file.path("inst", "python")
)
for (obj in names(the_py_module)) {
assign(obj, NULL)
}
obj
the_module <<- reticulate::import_from_path("the_py_module",
system.file("python", "the_py_package",
package = packageName(), mustWork = TRUE))
path <- system.file("python", package = "text")
path
path <- system.file("inst/python", package = "text")
path
path <- system.file("python", package = "text")
path
path <- system.file("inst/python", package = "text")
path
module <- reticulate::import_from_path(the_py_module, path = path)
path <- file.path("inst", "python")
path
module <- reticulate::import_from_path(the_py_module, path = path)
path
the_py_module <- reticulate::import_from_path(
"the_py_module",
file.path("inst", "python")
)
the_py_module
the_py_module$f1
text::the_py_module$f1
the_py_module$f1
the_py_module$f1
f1
library(text)
library(text)
# Function from python file
hg_embeddings <- hgTransformerGetEmbedding(text_strings = data,
pretrained_weights = pretrained_weights,
tokenizer_class = tokenizer_class,
model_class = model_class,
layers = layers,  # all or a list of layers to keep
return_tokens = return_tokens)
# Function from python file
hg_embeddings <- text::hgTransformerGetEmbedding(text_strings = data,
pretrained_weights = pretrained_weights,
tokenizer_class = tokenizer_class,
model_class = model_class,
layers = layers,  # all or a list of layers to keep
return_tokens = return_tokens)
# help(source_python)
# help(import_from_path)
library(text)
# Function from python file
hg_embeddings <- hgTransformerGetEmbedding(text_strings = data,
pretrained_weights = pretrained_weights,
tokenizer_class = tokenizer_class,
model_class = model_class,
layers = layers,  # all or a list of layers to keep
return_tokens = return_tokens)
reticulate::configure_environment(pkgname)
oldwd <- getwd()
oldwd
setwd(system.file(package = "text", "python"))
getwd()
nlp <- reticulate::import("huggingface_Interface", convert = TRUE, delay_load = TRUE)
nlp
assign("nlp", value = nlp, envir = parent.env(local))
assign("nlp", value = nlp)
# Function from python file
hg_embeddings <- hgTransformerGetEmbedding(text_strings = data,
pretrained_weights = pretrained_weights,
tokenizer_class = tokenizer_class,
model_class = model_class,
layers = layers,  # all or a list of layers to keep
return_tokens = return_tokens)
library(text)
# Function from python file
hg_embeddings <- hgTransformerGetEmbedding(text_strings = data,
pretrained_weights = pretrained_weights,
tokenizer_class = tokenizer_class,
model_class = model_class,
layers = layers,  # all or a list of layers to keep
return_tokens = return_tokens)
textTransform(x)
x <-  c("I am here", "where are you")
textTransform(x)
library(text)
textTransform(x)
help(import_from_path)
library(text)
textTransform(x)
pyscript <- system.file(package = "text", "python", "huggingface_Interface.py")
nlp <- reticulate::import("huggingface_Interface", convert = TRUE, delay_load = TRUE)
source_python(pyscript, envir = nlp, convert = TRUE)
source_python(pyscript, envir = nlp, convert = TRUE)
source_python(pyscript, envir = nlp, convert = TRUE)
textTransform(x)
source_python(pyscript, convert = TRUE)
textTransform(x)
source('~/Desktop/1 Projects/0 Research/0 text r-package/text/R/zzz.R')
source_python(pyscript, envir = local, convert = TRUE)
textTransform(x)
install.packages(golgotha)
install.packages("golgotha")
version(reticulate)
sessionInfo()
library(reticulate)
sessionInfo()
library(reticulate)
sessionInfo()
install.packages("golgotha")
sessionInfo()
