# Compute cosine between the simmed word embedding
cosine_observed <- lsa::cosine(X_all, Y_all)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
### Compute comparison distrubution of cosine based on randomly drawn word embeddings from both groups
# adding groups together
x1y1 <- rbind(x1, y1)
# Setting up parallel processing; Npermutations=100 Nthread = 2 help(splitIndices)
splitix <- parallel::splitIndices(nx = Npermutations, ncl = N_cluster_nodes)
splitix <- splitix[sapply(splitix, length) > 0]
distribution_mean_cosine_permutated <- parallel::mclapply(splitix, function(x, xx, yy) {
mean_cosine_permutated <- sapply(x, function(x, xx, yy) {
# Get indices for how to randomly split the word embeddings
indices <- sample(c((rep(TRUE, nrow(x1y1)/2)), (rep(FALSE, nrow(x1y1)/2))), nrow(x1y1), replace=FALSE)
# Randomly select word embeddings into two different data frames
rdata1 <- x1y1[indices, ]
rdata2 <- x1y1[!indices, ]
# Compute the cosine between randomly drawn word embeddings and compute the mean
if(method == "paired"){
rcosines <- cosines(rdata1, rdata2)
return(mean(abs(rcosines)))
}
if(method == "unpaired"){
R1_all <- textEmbeddingAggregation(rdata1, aggregation = "mean")
R2_all <- textEmbeddingAggregation(rdata2, aggregation = "mean")
# Compute cosine between the simmed word embedding
rcosines <- lsa::cosine(R1_all, R2_all)
# Compute the data's mean of the cosine
return(abs(rcosines))
}
}, xx=xx, yy=yy)
return (mean_cosine_permutated)
}, xx=x, yy=y)
NULLresults <- unlist(distribution_mean_cosine_permutated)
# Examine how the ordered data's mean of the cosine compare with the random data's, null comparison distribution
switch(alternative,
"two.sided" = {
results["p.value"] <- 2 * (min(sum(NULLresults < results["estimate"]), sum(NULLresults > results["estimate"])) / sum(!is.na(NULLresults)))
},
"less" = {
results["p.value"] <- sum(NULLresults < results["estimate"]) / sum(!is.na(NULLresults))
},
"greater" = {
results["p.value"] <- sum(NULLresults > results["estimate"]) / sum(!is.na(NULLresults))
}
)
if (results["p.value"] == 0) { results["p.value"] <- 1 / (Npermutations + 1) }
}
results <- as.list(results)
if (output.permutations) {
results <- c(list("random.estimates.4.null" = NULLresults, results))
}
return (results)
}
x <- wordembeddings4_10$harmonywords
y <- wordembeddings4_10$satisfactionwords
textDiff <- function(x, y, Npermutations = 1000, method = "paired", alternative = c("two.sided", "less", "greater"), output.permutations = TRUE, N_cluster_nodes = 1) {
set.seed(2020)
if ((nrow(x) != nrow(y))) { stop("x and y must have the same number of rows for a paired textDiff test.") }
alternative <- match.arg(alternative)
results <- c("estimate"=NA, "p.value"=NA)
# Select variables beginning with V
x1 <- dplyr::select(x, dplyr::starts_with("V"))
y1 <- dplyr::select(y, dplyr::starts_with("V"))
if(method == "paired") {
# Compute cosine between all pairs
cosine_observed <- cosines(x1, y1)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
if(method == "unpaired"){
X_all <- textEmbeddingAggregation(x1, aggregation = "mean")
Y_all <- textEmbeddingAggregation(y1, aggregation = "mean")
# Compute cosine between the simmed word embedding
cosine_observed <- lsa::cosine(X_all, Y_all)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
### Compute comparison distrubution of cosine based on randomly drawn word embeddings from both groups
# adding groups together
x1y1 <- rbind(x1, y1)
# Setting up parallel processing; Npermutations=100 Nthread = 2 help(splitIndices)
splitix <- parallel::splitIndices(nx = Npermutations, ncl = N_cluster_nodes)
splitix <- splitix[sapply(splitix, length) > 0]
distribution_mean_cosine_permutated <- parallel::mclapply(splitix, function(x, xx, yy) {
mean_cosine_permutated <- sapply(x, function(x, xx, yy) {
# Get indices for how to randomly split the word embeddings
indices <- sample(c((rep(TRUE, nrow(x1y1)/2)), (rep(FALSE, nrow(x1y1)/2))), nrow(x1y1), replace=FALSE)
# Randomly select word embeddings into two different data frames
rdata1 <- x1y1[indices, ]
rdata2 <- x1y1[!indices, ]
# Compute the cosine between randomly drawn word embeddings and compute the mean
if(method == "paired"){
rcosines <- cosines(rdata1, rdata2)
return(mean(abs(rcosines)))
}
if(method == "unpaired"){
R1_all <- textEmbeddingAggregation(rdata1, aggregation = "mean")
R2_all <- textEmbeddingAggregation(rdata2, aggregation = "mean")
# Compute cosine between the simmed word embedding
rcosines <- lsa::cosine(R1_all, R2_all)
# Compute the data's mean of the cosine
return(abs(rcosines))
}
}, xx=xx, yy=yy)
return (mean_cosine_permutated)
}, xx=x, yy=y)
NULLresults <- unlist(distribution_mean_cosine_permutated)
# Examine how the ordered data's mean of the cosine compare with the random data's, null comparison distribution
switch(alternative,
"two.sided" = {
results["p.value"] <- 2 * (min(sum(NULLresults < results["estimate"]), sum(NULLresults > results["estimate"])) / sum(!is.na(NULLresults)))
},
"less" = {
results["p.value"] <- sum(NULLresults < results["estimate"]) / sum(!is.na(NULLresults))
},
"greater" = {
results["p.value"] <- sum(NULLresults > results["estimate"]) / sum(!is.na(NULLresults))
}
)
if (results["p.value"] == 0) { results["p.value"] <- 1 / (Npermutations + 1) }
}
x <- wordembeddings4_10$harmonywords
y <- wordembeddings4_10$satisfactionwords
textDiff <- function(x, y, Npermutations = 1000, method = "paired", alternative = c("two.sided", "less", "greater"), output.permutations = TRUE, N_cluster_nodes = 1) {
set.seed(2020)
if ((nrow(x) != nrow(y))) { stop("x and y must have the same number of rows for a paired textDiff test.") }
alternative <- match.arg(alternative)
results <- c("estimate"=NA, "p.value"=NA)
# Select variables beginning with V
x1 <- dplyr::select(x, dplyr::starts_with("V"))
y1 <- dplyr::select(y, dplyr::starts_with("V"))
if(method == "paired") {
# Compute cosine between all pairs
cosine_observed <- cosines(x1, y1)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
if(method == "unpaired"){
X_all <- textEmbeddingAggregation(x1, aggregation = "mean")
Y_all <- textEmbeddingAggregation(y1, aggregation = "mean")
# Compute cosine between the simmed word embedding
cosine_observed <- lsa::cosine(X_all, Y_all)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
### Compute comparison distrubution of cosine based on randomly drawn word embeddings from both groups
# adding groups together
x1y1 <- rbind(x1, y1)
# Setting up parallel processing; Npermutations=100 Nthread = 2 help(splitIndices)
splitix <- parallel::splitIndices(nx = Npermutations, ncl = N_cluster_nodes)
splitix <- splitix[sapply(splitix, length) > 0]
distribution_mean_cosine_permutated <- parallel::mclapply(splitix, function(x, xx, yy) {
mean_cosine_permutated <- sapply(x, function(x, xx, yy) {
# Get indices for how to randomly split the word embeddings
indices <- sample(c((rep(TRUE, nrow(x1y1)/2)), (rep(FALSE, nrow(x1y1)/2))), nrow(x1y1), replace=FALSE)
# Randomly select word embeddings into two different data frames
rdata1 <- x1y1[indices, ]
rdata2 <- x1y1[!indices, ]
# Compute the cosine between randomly drawn word embeddings and compute the mean
if(method == "paired"){
rcosines <- cosines(rdata1, rdata2)
return(mean(abs(rcosines)))
}
if(method == "unpaired"){
R1_all <- textEmbeddingAggregation(rdata1, aggregation = "mean")
R2_all <- textEmbeddingAggregation(rdata2, aggregation = "mean")
# Compute cosine between the simmed word embedding
rcosines <- lsa::cosine(R1_all, R2_all)
# Compute the data's mean of the cosine
return(abs(rcosines))
}
}, xx=xx, yy=yy)
return (mean_cosine_permutated)
}, xx=x, yy=y)
NULLresults <- unlist(distribution_mean_cosine_permutated)
# Examine how the ordered data's mean of the cosine compare with the random data's, null comparison distribution
switch(alternative,
"two.sided" = {
results["p.value"] <- 2 * (min(sum(NULLresults < results["estimate"]), sum(NULLresults > results["estimate"])) / sum(!is.na(NULLresults)))
},
"less" = {
results["p.value"] <- sum(NULLresults < results["estimate"]) / sum(!is.na(NULLresults))
},
"greater" = {
results["p.value"] <- sum(NULLresults > results["estimate"]) / sum(!is.na(NULLresults))
}
)
if (results["p.value"] == 0) { results["p.value"] <- 1 / (Npermutations + 1) }
#}
results <- as.list(results)
if (output.permutations) {
results <- c(list("random.estimates.4.null" = NULLresults, results))
}
return (results)
}
textDiff(x, y, Npermutation = 10, alternative="greater", N_cluster_nodes = 2)
#
#
#
library(text)
textDiff(x, y, Npermutation = 10, alternative="greater", N_cluster_nodes = 2)
textDiff(x, y, Npermutation = 10, alternative="greater", N_cluster_nodes = 2)
#
#
#
library(text)
x <- wordembeddings4_10$harmonywords
y <- wordembeddings4_10$satisfactionwords
textDiff <- function(x, y, Npermutations = 1000, method = "paired", alternative = c("two.sided", "less", "greater"), output.permutations = TRUE, N_cluster_nodes = 1) {
set.seed(2020)
if ((nrow(x) != nrow(y))) { stop("x and y must have the same number of rows for a paired textDiff test.") }
alternative <- match.arg(alternative)
results <- c("estimate"=NA, "p.value"=NA)
# Select variables beginning with V
x1 <- dplyr::select(x, dplyr::starts_with("V"))
y1 <- dplyr::select(y, dplyr::starts_with("V"))
if(method == "paired") {
# Compute cosine between all pairs
cosine_observed <- cosines(x1, y1)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
if(method == "unpaired"){
X_all <- textEmbeddingAggregation(x1, aggregation = "mean")
Y_all <- textEmbeddingAggregation(y1, aggregation = "mean")
# Compute cosine between the simmed word embedding
cosine_observed <- lsa::cosine(X_all, Y_all)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
### Compute comparison distrubution of cosine based on randomly drawn word embeddings from both groups
# adding groups together
x1y1 <- rbind(x1, y1)
# Setting up parallel processing; Npermutations=100 Nthread = 2 help(splitIndices)
splitix <- parallel::splitIndices(nx = Npermutations, ncl = N_cluster_nodes)
splitix <- splitix[sapply(splitix, length) > 0]
distribution_mean_cosine_permutated <- parallel::mclapply(splitix, function(x, xx, yy) {
mean_cosine_permutated <- sapply(x, function(x, xx, yy) {
# Get indices for how to randomly split the word embeddings
indices <- sample(c((rep(TRUE, nrow(x1y1)/2)), (rep(FALSE, nrow(x1y1)/2))), nrow(x1y1), replace=FALSE)
# Randomly select word embeddings into two different data frames
rdata1 <- x1y1[indices, ]
rdata2 <- x1y1[!indices, ]
# Compute the cosine between randomly drawn word embeddings and compute the mean
if(method == "paired"){
rcosines <- cosines(rdata1, rdata2)
return(mean(abs(rcosines)))
}
if(method == "unpaired"){
R1_all <- textEmbeddingAggregation(rdata1, aggregation = "mean")
R2_all <- textEmbeddingAggregation(rdata2, aggregation = "mean")
# Compute cosine between the simmed word embedding
rcosines <- lsa::cosine(R1_all, R2_all)
# Compute the data's mean of the cosine
return(abs(rcosines))
}
}, xx=xx, yy=yy)
return (mean_cosine_permutated)
}, xx=x, yy=y)
NULLresults <- unlist(distribution_mean_cosine_permutated)
# Examine how the ordered data's mean of the cosine compare with the random data's, null comparison distribution
switch(alternative,
"two.sided" = {
results["p.value"] <- 2 * (min(sum(NULLresults < results["estimate"]), sum(NULLresults > results["estimate"])) / sum(!is.na(NULLresults)))
},
"less" = {
results["p.value"] <- sum(NULLresults < results["estimate"]) / sum(!is.na(NULLresults))
},
"greater" = {
results["p.value"] <- sum(NULLresults > results["estimate"]) / sum(!is.na(NULLresults))
}
)
if (results["p.value"] == 0) { results["p.value"] <- 1 / (Npermutations + 1) }
#}
results <- as.list(results)
if (output.permutations) {
results <- c(list("random.estimates.4.null" = NULLresults, results))
}
return (results)
}
textDiff(x, y, Npermutation = 10, alternative="greater", N_cluster_nodes = 2)
#  devtools::document()
#' Compute cosine
#'
#' @param x a word embedding
#' @param y a word embedding
#' @return cosine between x and y.
#' @noRd
# Computing the cosine between two semantic represenations
cosines <- function(x, y) {
rowSums(x * y, na.rm = TRUE) / (sqrt(rowSums(x * x, na.rm = TRUE)) * sqrt(rowSums(y * y, na.rm = TRUE)))
}
textDiff(x, y, Npermutation = 10, alternative="greater", N_cluster_nodes = 2)
x <- wordembeddings4_10$harmonywords
y <- wordembeddings4_10$satisfactionwords
textDiff <- function(x, y, Npermutations = 1000, method = "paired", alternative = c("two.sided", "less", "greater"), output.permutations = TRUE, N_cluster_nodes = 1) {
set.seed(2020)
if ((nrow(x) != nrow(y))) { stop("x and y must have the same number of rows for a paired textDiff test.") }
alternative <- match.arg(alternative)
results <- c("estimate"=NA, "p.value"=NA)
# Select variables beginning with V
x1 <- dplyr::select(x, dplyr::starts_with("V"))
y1 <- dplyr::select(y, dplyr::starts_with("V"))
if(method == "paired") {
# Compute cosine between all pairs
cosine_observed <- cosines(x1, y1)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
if(method == "unpaired"){
X_all <- textEmbeddingAggregation(x1, aggregation = "mean")
Y_all <- textEmbeddingAggregation(y1, aggregation = "mean")
# Compute cosine between the simmed word embedding
cosine_observed <- lsa::cosine(X_all, Y_all)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
### Compute comparison distrubution of cosine based on randomly drawn word embeddings from both groups
# adding groups together
x1y1 <- rbind(x1, y1)
# Setting up parallel processing; Npermutations=100 Nthread = 2 help(splitIndices)
splitix <- parallel::splitIndices(nx = Npermutations, ncl = N_cluster_nodes)
splitix <- splitix[sapply(splitix, length) > 0]
distribution_mean_cosine_permutated <- parallel::mclapply(splitix, function(x, xx, yy) {
mean_cosine_permutated <- sapply(x, function(x, xx, yy) {
# Get indices for how to randomly split the word embeddings
indices <- sample(c((rep(TRUE, nrow(x1y1)/2)), (rep(FALSE, nrow(x1y1)/2))), nrow(x1y1), replace=FALSE)
# Randomly select word embeddings into two different data frames
rdata1 <- x1y1[indices, ]
rdata2 <- x1y1[!indices, ]
# Compute the cosine between randomly drawn word embeddings and compute the mean
if(method == "paired"){
rcosines <- cosines(rdata1, rdata2)
return(mean(abs(rcosines)))
}
if(method == "unpaired"){
R1_all <- textEmbeddingAggregation(rdata1, aggregation = "mean")
R2_all <- textEmbeddingAggregation(rdata2, aggregation = "mean")
# Compute cosine between the simmed word embedding
rcosines <- lsa::cosine(R1_all, R2_all)
# Compute the data's mean of the cosine
return(abs(rcosines))
}
}, xx=xx, yy=yy)
return (mean_cosine_permutated)
}, xx=x, yy=y)
NULLresults <- unlist(distribution_mean_cosine_permutated)
# Examine how the ordered data's mean of the cosine compare with the random data's, null comparison distribution
switch(alternative,
"two.sided" = {
results["p.value"] <- 2 * (min(sum(NULLresults < results["estimate"]), sum(NULLresults > results["estimate"])) / sum(!is.na(NULLresults)))
},
"less" = {
results["p.value"] <- sum(NULLresults < results["estimate"]) / sum(!is.na(NULLresults))
},
"greater" = {
results["p.value"] <- sum(NULLresults > results["estimate"]) / sum(!is.na(NULLresults))
}
)
if (results["p.value"] == 0) { results["p.value"] <- 1 / (Npermutations + 1) }
#}
results <- as.list(results)
if (output.permutations) {
results <- c(list("random.estimates.4.null" = NULLresults, results))
}
return (results)
}
textDiff(x, y, Npermutation = 10, alternative="greater", N_cluster_nodes = 2)
textDiff <- function(x, y, Npermutations = 1000, method = "paired", alternative = c("two.sided", "less", "greater"), output.permutations = TRUE, N_cluster_nodes = 1) {
set.seed(2020)
if ((nrow(x) != nrow(y))) { stop("x and y must have the same number of rows for a paired textDiff test.") }
alternative <- match.arg(alternative)
results <- c("estimate"=NA, "p.value"=NA)
# Select variables beginning with V
x1 <- dplyr::select(x, dplyr::starts_with("V"))
y1 <- dplyr::select(y, dplyr::starts_with("V"))
if(method == "paired") {
# Compute cosine between all pairs
cosine_observed <- cosines(x1, y1)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
if(method == "unpaired"){
X_all <- textEmbeddingAggregation(x1, aggregation = "mean")
Y_all <- textEmbeddingAggregation(y1, aggregation = "mean")
# Compute cosine between the simmed word embedding
cosine_observed <- lsa::cosine(X_all, Y_all)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
### Compute comparison distrubution of cosine based on randomly drawn word embeddings from both groups
# adding groups together
x1y1 <- rbind(x1, y1)
# Setting up parallel processing; Npermutations=100 Nthread = 2 help(splitIndices)
splitix <- parallel::splitIndices(nx = Npermutations, ncl = N_cluster_nodes)
splitix <- splitix[sapply(splitix, length) > 0]
distribution_mean_cosine_permutated <- parallel::mclapply(splitix, function(x, xx, yy) {
mean_cosine_permutated <- sapply(x, function(x, xx, yy) {
# Get indices for how to randomly split the word embeddings
indices <- sample(c((rep(TRUE, nrow(x1y1)/2)), (rep(FALSE, nrow(x1y1)/2))), nrow(x1y1), replace=FALSE)
# Randomly select word embeddings into two different data frames
rdata1 <- x1y1[indices, ]
rdata2 <- x1y1[!indices, ]
# Compute the cosine between randomly drawn word embeddings and compute the mean
if(method == "paired"){
rcosines <- cosines(rdata1, rdata2)
return(mean(abs(rcosines)))
}
if(method == "unpaired"){
R1_all <- textEmbeddingAggregation(rdata1, aggregation = "mean")
R2_all <- textEmbeddingAggregation(rdata2, aggregation = "mean")
# Compute cosine between the simmed word embedding
rcosines <- lsa::cosine(R1_all, R2_all)
# Compute the data's mean of the cosine
return(abs(rcosines))
}
}, xx=xx, yy=yy)
return (mean_cosine_permutated)
}, xx=x, yy=y)
NULLresults <- unlist(distribution_mean_cosine_permutated)
# Examine how the ordered data's mean of the cosine compare with the random data's, null comparison distribution
switch(alternative,
"two.sided" = {
results["p.value"] <- 2 * (min(sum(NULLresults < results["estimate"]), sum(NULLresults > results["estimate"])) / sum(!is.na(NULLresults)))
},
"less" = {
results["p.value"] <- sum(NULLresults < results["estimate"]) / sum(!is.na(NULLresults))
},
"greater" = {
results["p.value"] <- sum(NULLresults > results["estimate"]) / sum(!is.na(NULLresults))
}
)
if (results["p.value"] == 0) { results["p.value"] <- 1 / (Npermutations + 1) }
}
textDiff <- function(x, y, Npermutations = 1000, method = "paired", alternative = c("two.sided", "less", "greater"), output.permutations = TRUE, N_cluster_nodes = 1) {
set.seed(2020)
if ((nrow(x) != nrow(y))) { stop("x and y must have the same number of rows for a paired textDiff test.") }
alternative <- match.arg(alternative)
results <- c("estimate"=NA, "p.value"=NA)
# Select variables beginning with V
x1 <- dplyr::select(x, dplyr::starts_with("V"))
y1 <- dplyr::select(y, dplyr::starts_with("V"))
if(method == "paired") {
# Compute cosine between all pairs
cosine_observed <- cosines(x1, y1)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
if(method == "unpaired"){
X_all <- textEmbeddingAggregation(x1, aggregation = "mean")
Y_all <- textEmbeddingAggregation(y1, aggregation = "mean")
# Compute cosine between the simmed word embedding
cosine_observed <- lsa::cosine(X_all, Y_all)
# Compute the data's mean of the cosine
results["estimate"] <- mean(abs(cosine_observed))
}
### Compute comparison distrubution of cosine based on randomly drawn word embeddings from both groups
# adding groups together
x1y1 <- rbind(x1, y1)
# Setting up parallel processing; Npermutations=100 Nthread = 2 help(splitIndices)
splitix <- parallel::splitIndices(nx = Npermutations, ncl = N_cluster_nodes)
splitix <- splitix[sapply(splitix, length) > 0]
distribution_mean_cosine_permutated <- parallel::mclapply(splitix, function(x, xx, yy) {
mean_cosine_permutated <- sapply(x, function(x, xx, yy) {
# Get indices for how to randomly split the word embeddings
indices <- sample(c((rep(TRUE, nrow(x1y1)/2)), (rep(FALSE, nrow(x1y1)/2))), nrow(x1y1), replace=FALSE)
# Randomly select word embeddings into two different data frames
rdata1 <- x1y1[indices, ]
rdata2 <- x1y1[!indices, ]
# Compute the cosine between randomly drawn word embeddings and compute the mean
if(method == "paired"){
rcosines <- cosines(rdata1, rdata2)
return(mean(abs(rcosines)))
}
if(method == "unpaired"){
R1_all <- textEmbeddingAggregation(rdata1, aggregation = "mean")
R2_all <- textEmbeddingAggregation(rdata2, aggregation = "mean")
# Compute cosine between the simmed word embedding
rcosines <- lsa::cosine(R1_all, R2_all)
# Compute the data's mean of the cosine
return(abs(rcosines))
}
}, xx=xx, yy=yy)
return (mean_cosine_permutated)
}, xx=x, yy=y)
NULLresults <- unlist(distribution_mean_cosine_permutated)
# Examine how the ordered data's mean of the cosine compare with the random data's, null comparison distribution
switch(alternative,
"two.sided" = {
results["p.value"] <- 2 * (min(sum(NULLresults < results["estimate"]), sum(NULLresults > results["estimate"])) / sum(!is.na(NULLresults)))
},
"less" = {
results["p.value"] <- sum(NULLresults < results["estimate"]) / sum(!is.na(NULLresults))
},
"greater" = {
results["p.value"] <- sum(NULLresults > results["estimate"]) / sum(!is.na(NULLresults))
}
)
if (results["p.value"] == 0) { results["p.value"] <- 1 / (Npermutations + 1) }
#}
results <- as.list(results)
if (output.permutations) {
results <- c(list("random.estimates.4.null" = NULLresults, results))
}
return (results)
}
textDiff(x, y, Npermutation = 10, alternative="greater", N_cluster_nodes = 2)
devtools::document()
devtools::document()
devtools::document()
